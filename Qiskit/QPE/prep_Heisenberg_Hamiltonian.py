#!/usr/bin/env python3
__author__ = "Jan Balewski"
__email__ = "janstar1122@gmail.com"
"""
Eigenstate Preparation and Verification Script

This script serves two main purposes:
1.  Classical Computation of Eigenstates: It defines a 2-qubit or 3-qubit
    Heisenberg-type Hamiltonian and uses classical linear algebra (numpy)
    to compute its exact eigenvalues and eigenvectors.

2.  Quantum Circuit Preparation: It takes a classically computed eigenvector
    (selected by an index via command-line) and constructs a Qiskit quantum
    circuit that prepares this specific quantum state from the initial |0...0> state.

The script includes verification steps to ensure the quantum circuit correctly
generates the desired eigenstate and that this state is indeed an eigenstate
of the specified Hamiltonian.

Usage:
    - To prepare the ground state (index 0) of the default 3-qubit Hamiltonian:
      python bb3.py

    - To prepare the first excited state (index 1) of the 2-qubit Hamiltonian:
      python bb3.py --nq_ham 2 --evIdx 1
"""
import argparse
import numpy as np
from qiskit import QuantumCircuit, transpile
from qiskit.quantum_info import SparsePauliOp, Statevector

def create_heisenberg_hamiltonian(n_qubits: int) -> SparsePauliOp:
    """
    Creates a Heisenberg-type Hamiltonian for a specified number of qubits.
    """
    if n_qubits == 2:
        # H = -1.5*XX + 1.0*YY - 0.9*ZZ
        paulis = ["XX", "YY", "ZZ"]
        coeffs = [-1.5, 1.0, -0.9]
    elif n_qubits == 3:
        # H = 0.5*XXI - 1.0*IYY + 0.8*ZIZ
        paulis = ["XXI", "IYY", "ZIZ"]
        coeffs = [0.5, -1.0, 0.8]
    else:
        raise NotImplementedError("This script currently only supports 2 and 3-qubit Heisenberg Hamiltonians.")
    
    return SparsePauliOp(paulis, coeffs)

def compute_eigenstates(hamiltonian: SparsePauliOp):
    """
    Computes the eigenvalues and eigenvectors of a Hamiltonian using matrix mechanics.
    (Logic from bb1.py)
    """
    hamiltonian_matrix = hamiltonian.to_matrix()
    print("Computing eigenvalues and eigenvectors of the Hamiltonian matrix...")
    eigenvalues, eigenvectors = np.linalg.eigh(hamiltonian_matrix)
    return eigenvalues, eigenvectors

def prepare_eigenstate_circuit(eigenvector: np.ndarray) -> QuantumCircuit:
    """
    Prepares a Qiskit circuit initialized to a specific eigenstate.
    (Logic from bb2.py)
    """
    num_qubits = int(np.log2(len(eigenvector)))
    qc = QuantumCircuit(num_qubits, name="eigenstate")
    # The `initialize` method prepares a state. It is the inverse of a state preparation circuit.
    # To get a circuit that prepares the state from |0...0>, we need its inverse.
    qc.initialize(eigenvector, qc.qubits)
    qcT = transpile(qc, basis_gates=['u','cx'])
    
    # Remove leading resets and show the simplified circuit
    qcT2 = strip_leading_resets(qcT)
    return qcT2


def strip_leading_resets(qcT: QuantumCircuit) -> QuantumCircuit:
    """Return a copy of qcT with any leading reset instructions removed.

    Only resets at the very beginning of the circuit are removed. Resets
    appearing after the first non-reset instruction are preserved.
    """
    new_qc = QuantumCircuit(*qcT.qregs, *qcT.cregs, name=qcT.name)
    for instr, qargs, cargs in qcT.data:
        if  instr.name == 'reset': continue
        new_qc.append(instr, qargs, cargs)
    return new_qc

def check_if_eigenstate(hamiltonian: SparsePauliOp, circuit: QuantumCircuit):
    """
    Verifies that the state prepared by a circuit is an eigenstate of the Hamiltonian.
    It checks if H|psi> = E|psi> for the state |psi> generated by the circuit.
    """
    print("\n--- Verifying Eigenstate from Circuit Against Hamiltonian ---")
    
    # 1. Get the statevector produced by the circuit
    try:
        statevector = Statevector.from_instruction(circuit)
    except Exception as e:
        print(f"Error: Could not create statevector from the provided circuit. {e}")
        return

    # 2. Get the Hamiltonian matrix
    ham_matrix = hamiltonian.to_matrix()

    # 3. Apply the Hamiltonian to the statevector: H|psi>
    final_vector = ham_matrix @ statevector.data
    
    # 4. Find the eigenvalue E by comparing the most significant element
    # This avoids division by zero or small numbers for sparse statevectors
    idx = np.argmax(np.abs(statevector.data))
    eigenvalue = final_vector[idx] / statevector.data[idx]
    
    # 5. Check if H|psi> is proportional to |psi>
    is_eigen = np.allclose(final_vector, eigenvalue * statevector.data)
    
    print(f"Is the circuit's state an eigenstate of the Hamiltonian? -> {is_eigen}")
    if is_eigen:
        print(f"  - Verified Eigenvalue (Energy): {eigenvalue.real:.6f}")
    else:
        # If not an eigenstate, the relationship doesn't hold.
        # We can compute the expectation value <psi|H|psi> for reference.
        expected_energy = np.vdot(statevector.data, final_vector).real
        print(f"  - The state is not a perfect eigenstate.")
        print(f"  - Expectation value <psi|H|psi> is: {expected_energy:.6f}")
    print("-----------------------------------------------------------\n")
    
def main():
    """
    Main function to compute and prepare an eigenstate of the Heisenberg Hamiltonian.
    """
    parser = argparse.ArgumentParser(description="Compute and prepare an eigenstate of a Hamiltonian.")
    parser.add_argument("--nq_ham", type=int, default=3, help="Number of qubits in the Hamiltonian (default: 3).")
    parser.add_argument("--evIdx", type=int, default=0, help="Index of the eigenstate to prepare (0 for ground state).")
    args = parser.parse_args()
    print(vars(args))
    
    print(f"--- Eigenstate Preparation for {args.nq_ham}-qubit Heisenberg Model ---")
    
    # 1. Create Hamiltonian
    try:
        hamiltonian = create_heisenberg_hamiltonian(args.nq_ham)
        print("Hamiltonian created:\n", hamiltonian)
    except NotImplementedError as e:
        print(f"Error: {e}")
        return

    # 2. Compute eigenstates
    eigenvalues, eigenvectors = compute_eigenstates(hamiltonian)
    print('all %d eigenvalues:'%(len(eigenvalues)),eigenvalues)
    
    # 3. Select the desired eigenstate
    if not (0 <= args.evIdx < len(eigenvalues)):
        print(f"Error: --evIdx must be between 0 and {len(eigenvalues) - 1}. You provided {args.evIdx}.")
        return
        
    selected_eigenvalue = eigenvalues[args.evIdx]
    # In numpy's eigh, eigenvectors are stored as columns in the matrix
    selected_eigenvector = eigenvectors[:, args.evIdx]

    print(f"\nSelected eigenstate (index {args.evIdx}):")
    print(f"  - Eigenvalue (Energy): {selected_eigenvalue.real:.6f}")
    
    # 4. Prepare the Qiskit circuit for this state
    print("\nPreparing Qiskit circuit to generate the eigenstate from |0...0>...")
    qc = prepare_eigenstate_circuit(selected_eigenvector)
    
    # 5. Display results
    print("Circuit diagram:")
    print(qc)

    qcT = transpile(qc, basis_gates=['u','cx'])
    print(qcT.draw())
   
    # Verification step
    final_state = Statevector.from_instruction(qcT)
    is_correct = np.allclose(final_state.data, selected_eigenvector)
    print(f"\nVerification: Does the circuit produce the correct statevector? -> {is_correct}")
    if not is_correct:
        print("Mismatch between expected eigenvector and circuit's final statevector.")
    
    # Final check using the transpiled circuit and the Hamiltonian
    check_if_eigenstate(hamiltonian, qcT)

    print('WARNING - code works incrreclty - need debugging')

if __name__ == "__main__":
    main()
